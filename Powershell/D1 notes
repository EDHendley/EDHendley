xfreerdp /u:student /v:10.50.45.158 -dynamic-resolution +glyph-cache +clipboard
some tools
xfreerdp
IDA pro
Ghidra
PowerShell ISE

Powershell is a object-oriented language, class and object based so has coinciding methods and attribute. 


syntax uses a Verb-Noun structure, "commands" are cmdlets (command lets)
Verb-Noun -[option] <string[]> -[option] <string[*inputs]> ... etc      *may accept multiple inputs  

Get-Command
Get-Command -Noun <name>
Get-Verb
Get-Process

Want info on a command?
Get-Help <cmdlet>
Get-Help Get-Command
Get-Help Get-Process -Full
"        "           -showwindow
"        "           -online   (preferred help resource)
"        *log*    (or something else, shows you what you can do with whatever in the wild card)
Want to update help pages?
Update-Help -Force -ErrorAction SilentlyContinue

instead of ls or dir
Get-ChildItem
PS will still accept ls or dir but it is an alias
Get-Alias
Want to clear screen?
cls (alias for Clear-Host)
want to remove an alias?
Remove-Item alias:<alias_name_here>
ex
Set-Alias edit notepad.exe
edit  (will open notepad)
Remove-Item alias:edit

want to see all the alias for a cmdlet? for ex, childitem has many aliases attached to it
Get-Alias -Definition Get-ChildItem

want to see all the methods and properties of a proccess?
Get-Process | Get-Member

Pipes and Powershell

Get-Service | Format-Table Name, Status

dir config.log | Rename-Iem -NewName {"old_$($_.Name)"}    every file in config.log will be renamed with "old_" appended to the front of it

write-host vs write-output
-host goes to the screen no matter what
-output goes to standrd output, which could be screen, pipe, etc

"double quotes allows variable expansion so you can call a variable within a string denoted with """
ex 
$var = "Jon"
1. Write-Host "hello $var"
'single quotes returns what is inside as literal'
2. Write-Host 'hello $var"

in first instance the " " will return "hello Jon" to the screen
In the second, the ' ' will return 'hello $var' because it got the literal string

to check the type of a variable, ($var).GetType()

$var = [int32](read-host)
read-host is basically input, takes input from user
write-host is print
===============================================================================================================
Script block / code block
$myblock = { Get-Service | Format-Table Name, Status }    <----notice the curlies, this is NOT a variable, its a script block
& $myblock   <---- how to callback the script block
^  dont forget the and/ampersand
the & is an alias for invoke-command

$a=Get-Process notepad
$b = {Get-Process notepad }

the difference is the variable $a is static, once run it will store the process info for notepad, once notepad is terminated the data remains
with script block & $b, when it is run it will store the same info but once notepad is terminated the info is no longer stored, it is dynamic

Get-ChildItem | Sort-Object -Property Extension | Format-Table -Groupby Extension
  each type of extension will get their own table. clean and easy way to find files by different extensions

Get-Service | Group-Object Status | ft -GroupBy Status     ft is Format-Table

Get-Service | Group-Object {$_.Name.Substring(0,1).ToUpper()} | ForEach-Object{($_.Name + " ") *7; "==========" $_.Group}

Get-Variable | Sort-Object Name | ft -property Name, Description -AutoSize -wrap

Get-Serice | Where-Object{$_.Status -eq 'running'}

Get-ChildItem *.txt | Where-Object {$_.Length -gt 100}

Get-Service | Get-Member

Get-Process | Where-Object {$_.Company -like 'micro*'} | Fortmat-Table Name, Description, Company

Get-Process | Where-Object {$_.Name -notlike 'powershell*'} | Sort-Object id -Descending

Get-Process | Where-Object processname -ne "Idle" | sort-object starttime | Select-Object -ErrorAction ft processname, starttime






